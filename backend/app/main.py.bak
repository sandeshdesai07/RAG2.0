# backend/app/main.py
import os
from datetime import datetime

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# DB clients
from motor.motor_asyncio import AsyncIOMotorClient
from sqlalchemy import create_engine, text

# utils (ensure these files exist: app/utils/safe_eval.py and app/utils/parser.py)
from app.utils.safe_eval import safe_eval
from app.utils.parser import extract_vars

# ----- App setup -----
app = FastAPI()

# CORS for local dev frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ----- Config / URIs -----
MONGO_URI = os.getenv("MONGO_URI", "mongodb://mongo:27017")
POSTGRES_URI = os.getenv(
    "DATABASE_URL",
    "postgresql://physic_user:physic_pass@postgres:5432/physic_db"
)

# ----- Mongo client (async) -----
mongo_client = AsyncIOMotorClient(MONGO_URI)
mongo_db = mongo_client["physicalc"]

# ----- Postgres engine (sync helper) -----
pg_engine = create_engine(POSTGRES_URI, echo=False, future=True)

# ----- Request/response models -----
class AskIn(BaseModel):
    user_id: int = 0
    text: str

# ----- Health endpoint -----
@app.get("/health")
def health():
    try:
        with pg_engine.connect() as conn:
            conn.execute(text("SELECT 1"))
    except Exception as e:
        return {"status": "db_error", "error": str(e)}
    return {"status": "ok", "time": datetime.utcnow().isoformat()}


# ----- Ask endpoint (parser -> lookup -> compute -> store) -----
@app.post("/api/ask")
async def ask(payload: AskIn):
    # base document to store
    doc = {
        "user_id": payload.user_id,
        "text": payload.text,
        "parsed": None,
        "answer": None,
        "source": None,
        "timestamp": datetime.utcnow()
    }

    # parse variables from text
    vars_found = extract_vars(payload.text)
    doc["parsed"] = vars_found

    # Try a better Postgres lookup using the whole user text (safer than only first token)
    match = None
    search_text = payload.text.strip()
    if search_text:
        try:
            with pg_engine.connect() as conn:
                q = text(
                    "SELECT id, name, expression, units, description FROM formulas "
                    "WHERE name ILIKE :q OR description ILIKE :q LIMIT 1"
                )
                res = conn.execute(q, {"q": f"%{search_text}%"}).fetchone()
                if res:
                    match = {"id": res[0], "name": res[1], "expression": res[2], "units": res[3], "description": res[4]}
        except Exception as e:
            print("Postgres lookup error:", e)

    answer = None
    source = None

    if match:
        expr = match.get("expression")
        try:
            # determine variables used in the formula (AST)
            import ast
            parsed = ast.parse(expr, mode="eval")
            varnames = {n.id for n in ast.walk(parsed) if isinstance(n, ast.Name)}

            if varnames and varnames.issubset(set(vars_found.keys())):
                val = safe_eval(expr, vars_found)
                answer = float(val)
                source = {
                    "title": match.get("name"),
                    "description": match.get("description"),
                    "url": None,
                    "formula_id": int(match.get("id"))
                }
            else:
                answer = "need_more_vars"
        except Exception as exc:
            print("Evaluation error:", exc)
            answer = "error"
    else:
        answer = "no_formula_found"

    # store result
    doc["answer"] = answer if not isinstance(answer, float) else {"value": answer}
    doc["source"] = source

    insert_res = await mongo_db.queries.insert_one(doc)
    return {"query_id": str(insert_res.inserted_id), "answer": doc["answer"], "source": source}
